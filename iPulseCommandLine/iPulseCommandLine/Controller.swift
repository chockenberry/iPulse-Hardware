//
//  Controller.swift
//  iPulseCommandLine
//
//  Created by Craig Hockenberry on 2/24/24.
//

import Foundation
import AppKit

// TODO: Currently Serial() manages the opened/closed state. It makes more sense to control the serial port from this controller
// using something like this: http://codeworkshop.net/posts/power-nap-and-the-network

class Controller {
	
	let serial: Serial
	var timer: Timer?
	let collector = Collector()
	
	init() {
		serial = Serial(bsdPath: "/dev/cu.usbmodem1444201")
		serial.open()

		NSWorkspace.shared.notificationCenter.addObserver(self, selector: #selector(willSleep), name: NSWorkspace.willSleepNotification, object: nil)
		NSWorkspace.shared.notificationCenter.addObserver(self, selector: #selector(didWake), name: NSWorkspace.didWakeNotification, object: nil)
//		NSWorkspace.shared.notificationCenter.addObserver(self, selector: #selector(willSleep), name: NSWorkspace.screensDidSleepNotification, object: nil)
//		NSWorkspace.shared.notificationCenter.addObserver(self, selector: #selector(didWake), name: NSWorkspace.screensDidWakeNotification, object: nil)
		NSWorkspace.shared.notificationCenter.addObserver(self, selector: #selector(didBecomeActive), name: NSWorkspace.sessionDidBecomeActiveNotification, object: nil)
		NSWorkspace.shared.notificationCenter.addObserver(self, selector: #selector(didResignActive), name: NSWorkspace.sessionDidResignActiveNotification, object: nil)
		
	}

	deinit {
		serial.close()
	}
	
	@objc
	func willSleep(_ notification: Notification) {
		print("***** will sleep")
		serial.close()
	}

	@objc
	func didWake(_ notification: Notification) {
		print("***** did wake")
		serial.open()
	}

	@objc
	func didBecomeActive(_ notification: Notification) {
		print("***** did become active")
	}

	@objc
	func didResignActive(_ notification: Notification) {
		print("***** did resign active")
	}

	func start() {
		guard timer == nil else { return }
		timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { timer in
			self.collector.collect()
			
			var transfer = Transfer()
			if let processorSample = self.collector.processorSamples.last {
				let totalUsage = processorSample.coreSamples.reduce(0, { partialResult, coreSample in
					partialResult + coreSample.usage
				})
				transfer.cpuUsage = (Float(totalUsage) / Float(processorSample.coreSamples.count))
			}
			if let networkSample = self.collector.networkSamples.last {
				transfer.networkReceivedBps = networkSample.receivedBitsPerSecond
				transfer.networkSentBps = networkSample.sentBitsPerSecond
			}
			if let diskSample = self.collector.diskSamples.last {
				transfer.diskReadBytes = diskSample.readBytes
				transfer.diskWriteBytes = diskSample.writeBytes
			}
			let encoder = JSONEncoder()
			encoder.keyEncodingStrategy = .convertToSnakeCase
			//encoder.outputFormatting = [.withoutEscapingSlashes, .prettyPrinted]
			encoder.outputFormatting = [.withoutEscapingSlashes]
			do {
				let data = try encoder.encode(transfer)
				if let message = String(data: data, encoding: .utf8) {
					//debugLog("message = \(message)")
					self.serial.send(message)
					if let debug = self.serial.read() {
						// print any debugging output generated by the Arduino
						print(debug)
					}
				
				}
			}
			catch {
				debugLog("error = \(error.localizedDescription)")
			}
		}
	}
	
	func stop() {
		guard let timer else { return }
		
		timer.invalidate()
		self.timer = nil
	}
	
}
